{
  "template": {
		"prefix": "main",
		"body": "// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n//#include <atcoder/all>\nusing namespace std;\n//using namespace atcoder;\n\n#define int long long\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define REP(i, n) for (int i = 0; i < n; ++i)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x) cout << #x << \" = \" << (x) << endl;\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define SP << \" \" <<\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef vector<int> vec;\ntypedef vector<P> pvec;\ntypedef vector<vector<int>> vvec;\ntypedef vector<vector<P>> pvvec;\ntypedef priority_queue<int> PQI;\ntypedef priority_queue<P> PQP;\ntypedef priority_queue<int,vector<int>,greater<int>> PQIG;\ntypedef priority_queue<P,vector<P>,greater<P>> PQPG;\n\nconst vector<int> DX = {0, -1, 0, 1, 1, 1, -1, -1};\nconst vector<int> DY = {1, 0, -1, 0, 1, -1, 1, -1};\nconstexpr int MOD = (1000000007);\n// const int MOD = (998244353);\n// const int INF = (1 << 30); // 1073741824\nconst ll INF = (1LL << 60); // 1152921504606846976\nconst double PI = (3.141592653589794);\nconst double EPS = (0.0000000001); // 10^(-10)\n\ntemplate<class T> inline bool chmin(T& a, T b) {if (a > b) {a = b; return 1;} return 0;}\ntemplate<class T> inline bool chmax(T& a, T b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<class T> inline T ceil(T a, T b) {return T((a + b - 1) / b);}\ntemplate<class T> inline T round(T a, T b) {return T(a / b);}\ntemplate< typename T1, typename T2 > istream &operator>>(istream &is, pair< T1, T2 > &p) { is >> p.first >> p.second; return is; }\ntemplate <class T> inline void out(T &a) { bool flag=true; for(auto&x:a){if(flag) {flag=false;} else{ cout << ' '; } cout<<x; } cout << endl; }\n\n\n\n//----------------------------------------------------------------\nint nmax=200000; // 2*(10^5)\nvvec G(nmax);\n\n\n\n\n\nvoid solve4ts()\n{\n  \n  \n  $0\n  \n  \n}\n//-----------------------------------------------------------------\n\nsigned main(){ ios::sync_with_stdio(false); cin.tie(0); cout << fixed << setprecision(15);\n  int repeat = 1;\n  // cin >> repeat;\n  while(repeat--) solve4ts();\n}\n\n/*\n\ng++ -std=c++1z code.cpp\n\n./a.out\n\npython3 expander.py code.cpp\n\n*/",
		"description": ""
	},
	"bitall": {
		"prefix": "bitall",
		"body": "int Digit = 3; // 2進数の桁数を入力\nrep(_, (1 << Digit))\n{\n  rep(each, Digit)\n  {\n    if ((_ >> (Digit - 1 - each)) & (1))\n    { // 左からeach番目のbitが立っているとき\n    }\n    else\n    {\n    }\n  }\n}",
		"description": ""
	},
	"ax": {
		"prefix": "ax",
		"body": "int ax(vec &a, int x, int num) {\n  switch (num) { // 1…以下 2…以上 3…未満 4…超過 5…個数\n  case 1: return upper_bound(all(a), x) - a.begin();\n  case 2: return a.end() - lower_bound(all(a), x);\n  case 3: return lower_bound(all(a), x) - a.begin();\n  case 4: return a.end() - upper_bound(all(a), x);\n  case 5: return upper_bound(all(a), x) - lower_bound(all(a), x);\n  }\n}",
		"description": ""
	},
	"数学": {
		"prefix": "math",
		"body": [
			"int gcd(int x, int y) { return y ? gcd(y, x%y) : x; }",
			"int lcm(int x, int y) { return x/gcd(x, y)*y; }",
			"int mod_pow(int x, int y) { int res = 1; while (y > 0) { if (y & 1) { res = res * x % MOD; } x = x * x % MOD; y >>= 1; } return res; }",
			"int cmb(int n,int k){ if(n<k){ return 0;} int res=1,nn=n,kk=1;k=min(k,n-k); for(int i=0;i<k;i++){ res*=nn-i;res/=kk+i;} return res; }",
			"ll comb(ll n,ll k){ ll res=1; for(int i=0;i<k;i++){ (res*=(n-i)%MOD)%=MOD; } for(int i=1;i<=k;i++){ (res*=mod_pow(i,MOD-2))%=MOD; } return res; }",
			"int to_int(string s) { int n = s.size(); int ans = 0; for (int i = 0; i < n; i++) { ans = ((ans * 10) + (s[i] - '0')) % MOD; } return ans; }",
			"int DigitSum(int x){ int ret=0; while(x){ ret++;x/=10;} return ret; }",
			"bool is_prime(int n) { for(int i = 2; i*i <= n; i++) { if (n % i == 0) return false; } return n != 1; }",
			"int extgcd(int a, int b, int& x, int& y) { // ax+by = gcd(a,b) >> gcd(a,b)",
			"\tint d = a;",
			"\tif(d != 0) { d = extgcd(b, a%b, y, x); y -= (a/b)*x; }",
			"\telse { x = 1, y = 0; }",
			"\treturn 0;",
			"}"
		],
		"description": "数学"
	},
	"cin_vector_int": {
		"prefix": "cvi",
		"body": [
			"vector<int> $1($2);",
			"rep(i,$2) cin >> $1[i];",
			"$0"
		],
		"description": "cin_vector_int"
	},
  "mint": {
		"prefix": "mint",
		"body": "template <ll mod>\nstruct modint\n{\n  ll val = 0;\n  //コンストラクタ\n  modint(ll x = 0)\n  {\n    while (x < 0)\n      x += mod;\n    val = x % mod;\n  }\n  //コピーコンストラクタ\n  modint(const modint &r) { val = r.val; }\n  //算術演算子\n  constexpr modint operator-() const noexcept { return modint(-val); } //単項\n  constexpr modint operator+(const modint &r) const noexcept { return modint(*this) += r; }\n  constexpr modint operator-(const modint &r) const noexcept { return modint(*this) -= r; }\n  constexpr modint operator*(const modint &r) const noexcept { return modint(*this) *= r; }\n  constexpr modint operator/(const modint &r) const noexcept { return modint(*this) /= r; }\n  //代入演算子\n  constexpr modint &operator+=(const modint &r) noexcept\n  {\n    val += r.val;\n    if (val >= mod)\n      val -= mod;\n    return *this;\n  }\n  constexpr modint &operator-=(const modint &r) noexcept\n  {\n    if (val < r.val)\n      val += mod;\n    val -= r.val;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint &r) noexcept\n  {\n    val = val * r.val % mod;\n    return *this;\n  }\n  constexpr modint &operator/=(const modint &r) noexcept\n  {\n    ll a = r.val, b = mod, u = 1, v = 0;\n    while (b)\n    {\n      ll t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    val = val * u % mod;\n    if (val < 0)\n      val += mod;\n    return *this;\n  }\n  //等価比較演算子\n  constexpr bool operator==(const modint &r) const noexcept { return this->val == r.val; }\n  constexpr bool operator!=(const modint &r) const noexcept { return this->val != r.val; }\n  constexpr bool operator<(const modint &r) const noexcept { return this->val < r.val; }\n  constexpr bool operator>(const modint &r) const noexcept { return this->val > r.val; }\n  constexpr bool operator<=(const modint &r) const noexcept { return this->val <= r.val; }\n  constexpr bool operator>=(const modint &r) const noexcept { return this->val >= r.val; }\n  friend constexpr istream &operator>>(istream &is, modint &x) noexcept\n  {\n    ll t;\n    is >> t;\n    x = t;\n    return (is);\n  }\n  friend constexpr ostream &operator<<(ostream &os, const modint &x) noexcept\n  {\n    return os << x.val;\n  }\n  int getMod() { return mod; }\n  modint<mod> modpow(const modint<mod> &a, long long n) noexcept\n  {\n    if (n == 0)\n      return 1;\n    auto t = modpow(a, n / 2);\n    t = t * t;\n    if (n & 1)\n      t = t * a;\n    return t;\n  }\n};\nusing mint = modint<MOD>;\nusing mvec = vector<mint>;\nusing mvvec = vector<vector<mint>>;",
		"description": ""
	},
	"二項係数": {
		"prefix": "bc",
		"body": "// 二項係数ライブラリ\ntemplate <class T>\nstruct BC\n{\n  vector<T> fact_, inv_, finv_;\n  constexpr BC() {}\n  constexpr BC(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1)\n  {\n    init(n);\n  }\n  constexpr void init(int n) noexcept\n  {\n    fact_.assign(n, 1);\n    inv_.assign(n, 1);\n    finv_.assign(n, 1);\n    for (int i = 2; i < n; i++)\n    {\n      fact_[i] = fact_[i - 1] * i;\n      inv_[i] = -inv_[MOD % i] * (MOD / i);\n      finv_[i] = finv_[i - 1] * inv_[i];\n    }\n  }\n  constexpr T C(int n, int k) const noexcept\n  {\n    if (n < k || n < 0 || k < 0)\n      return 0;\n    return fact_[n] * finv_[k] * finv_[n - k];\n  }\n  constexpr T P(int n, int k) const noexcept\n  {\n    if (n < k || n < 0 || k < 0)\n      return 0;\n    return fact_[n] * finv_[n - k];\n  }\n  constexpr T H(int n, int k) const noexcept\n  {\n    return C(n + k - 1, k);\n  }\n  constexpr T fact(int n) const noexcept\n  {\n    if (n < 0)\n      return 0;\n    return fact_[n];\n  }\n  constexpr T inv(int n) const noexcept\n  {\n    if (n < 0)\n      return 0;\n    return inv_[n];\n  }\n  constexpr T finv(int n) const noexcept\n  {\n    if (n < 0)\n      return 0;\n    return finv_[n];\n  }\n};\nBC<mint> bc(100000);",
		"description": ""
	},
	"オーバーフロー検出": {
		"prefix": "over",
		"body": [
			"bool over_frow(int a, int b){",
			"  if(a == 0 || b == 0) return false;",
			"  return a > __LONG_LONG_MAX__/b;",
			"}"
		],
		"description": "オーバーフロー検出"
	},
	"dfs_tree": {
		"prefix": "tree",
		"body": [
			"const int N = $1;",
			"vector<int> edge[N];",
			"",
			"void dfs(int no, int par){",
			"  for(int to: edge[no]){",
			"    if(to==par) continue;",
			"    dfs(to,no);",
			"  }",
			"}"
		],
		"description": "木DFS"
	},
	"座圧": {
		"prefix": "comp",
		"body": [
			"template<typename T>",
			"vector<T> compress(vector<T> v){",
			"  sort(v.begin(),v.end());",
			"  v.erase(unique(v.begin(),v.end()),v.end());",
			"  return v;",
			"}",
			"",
			"template<typename T>",
			"map<T, int> dict(const vector<T> &v){",
			"  map<T, int> res;",
			"  for(int i=0;i<(int)v.size();i++)",
			"    res[v[i]]=i;",
			"  return res;",
			"}"
		],
		"description": "座圧"
	},
	"cin_vvector_int": {
		"prefix": "cvvi",
		"body": [
			"vector<vector<int>> $1($2,vector<int>($3));",
			"REP(i,$2) REP(j,$3) cin >> $1[i][j];",
			"$4"
		],
		"description": "cin_vvector_int"
	},
	"cin_vector_string": {
		"prefix": "cvs",
		"body": [
			"vector<string> $1($2);",
			"rep(i,$2) cin >> $1[i];",
			"$3"
		],
		"description": "cin_vector_string"
	},
	"cin_vector_pair": {
		"prefix": "cvp",
		"body": [
			"vector<P> $1($2);",
			"REP(i,$2){",
			"  int x,y;",
			"  cin >> x >> y;",
			"  $1[i] = P(x,y);",
			"}",
			"$3"
		],
		"description": "cin_vector_pair"
	},
	"cin_vector_graph": {
		"prefix": "cvg",
		"body": [
			"REP(_,$1){",
			"  int x,y;",
			"  cin >> x >> y;",
			"  x--; y--;",
			"  edge[x].emplace_back(y);",
			"  edge[y].emplace_back(x);",
			"}"
		],
		"description": "重み無し無向グラフの受取"
	},
	"cin_weighted_graph": {
		"prefix": "cwg",
		"body": [
			"Graph $1($2);",
			"REP(_,$3){",
			"  int node_x,node_y,cost = 1;",
			"  cin >> node_x >> node_y;",
			"  cin >> cost;  // 重みなしなら削除",
			"  node_x--; node_y--;",
			"  $1[node_x].pb(P(node_y,cost));",
			"  $1[node_y].pb(P(node_x,cost));",
			"}",
			"$4"
		],
		"description": "重み付き無向グラフの受取"
	},
	"divisor": {
		"prefix": "divi",
		"body": [
			"vector<int> divisor(const int n){",
			"  vector<int> ret;",
			"  for(int i=1;i*i<=n;i++){",
			"    if(n % i == 0){",
			"      ret.push_back(i);",
			"      if(i*i!= n) ret.push_back(n/i);",
			"    }",
			"  }",
			"  sort(ret.begin(),ret.end());",
			"  return ret;",
			"}"
		],
		"description": "約数列挙"
	},
	"matpow": {
		"prefix": "matpow",
		"body": [
			"int m;",
			"vec matmul(vec &dp, mat &mt){",
			"  vec ret(m,0);",
			"  REP(i,m) REP(j,m) ret[i] += mt[i][j]*dp[j];",
			"  return ret;",
			"}",
			"",
			"mat update(mat &mt){",
			"  mat ret(m,vec(m,0));",
			"  REP(i,m) REP(j,m) REP(k,m) ret[i][j] += mt[i][k]*mt[k][j];",
			"  return ret;",
			"}",
			"",
			"void matpow(vec &dp, mat &mt, int k){",
			"  m = dp.size();",
			"  while(k){",
			"    if(k%2) dp = matmul(dp,mt);",
			"    mt = update(mt);",
			"    k /= 2;",
			"  }",
			"}"
		],
		"description": "行列累乗"
	},
	"BIT": {
		"prefix": "BIT",
		"body": [
			"struct BIT{",
			"private:",
			"  vector<int> bit;",
			"  int num;",
			"",
			"public:",
			"  BIT(vector<int> v){",
			"    num = v.size();",
			"    bit.resize(num);",
			"    REP(i,num) bit[i] = v[i];",
			"  }",
			"",
			"  int sum(int i){",
			"    int s = 0;",
			"    while(i > 0){",
			"      s += bit[i];",
			"      i -= i & -i;",
			"    }",
			"    return s;",
			"  }",
			"",
			"  void add(int i, int x){",
			"    while(i <= num){",
			"      bit[i] += x;",
			"      i += i & -i;",
			"    }",
			"  }",
			"};"
		],
		"description": "BIT"
	},
	"dijkstra": {
		"prefix": "dijk",
		"body": [
			"typedef vector<vector<P> > Graph;",
			"vector<int> dijkstra(int s, Graph &G){",
			"  priority_queue<P,vector<P>,greater<P>> que;",
			"  int n = G.size();",
			"  vector<int> dist(n);",
			"  dist.assign(n,INF);",
			"  dist[s] = 0;",
			"  que.push(P(0,s));",
			"",
			"  while(!que.empty()){",
			"    P p = que.top();",
			"    que.pop();",
			"    int v = p.sc;",
			"    REP(i,G[v].size()){",
			"      if(dist[G[v][i].fs] > dist[v]+G[v][i].sc){",
			"        dist[G[v][i].fs] = dist[v]+G[v][i].sc;",
			"        que.push(P(dist[G[v][i].fs],G[v][i].fs));",
			"      }",
			"    }",
			"  }",
			"  return dist;",
			"}"
		],
		"description": "dijkstra"
	},
	"z_algorithm": {
		"prefix": "z_algo",
		"body": [
			"//文字列Sと、Sのi文字目からの文字列Tの最長一致の接頭辞長",
			"vector<int> z_algorithm(string& s){",
			"\tint n = s.size(), c = 0;",
			"\tvec ret(n);",
			"\tfor(int i = 1;i < n;i++){",
			"\t\tif(i+ret[i-c] < c + ret[c]) ret[i] = ret[i-c];",
			"\t\telse{",
			"\t\t\tint j = max(0LL,c+ret[c]-i);",
			"\t\t\twhile(i+j < n && s[j] == s[i+j]) j++;",
			"\t\t\tret[i] = j;",
			"\t\t\tc = i;",
			"\t\t}",
			"\t}",
			"\tret[0] = n;",
			"\treturn ret;",
			"}"
		],
		"description": "Zアルゴリズム"
	},
	"manacher": {
		"prefix": "manacher",
		"body": [
			"//文字列Sのi文字目を中心とした回文半径",
			"vector<int> manacher(string &S){",
			"  vector<int> R;",
			"  R.resize(S.size());",
			"  int i = 0, j = 0;",
			"  while (i < S.size()){",
			"    while (i-j >= 0 && i+j < S.size() && S[i-j] == S[i+j]) ++j;",
			"    R[i] = j;",
			"    int k = 1;",
			"    while (i-k >= 0 && i+k < S.size() && k+R[i-k] < j) R[i+k] = R[i-k], ++k;",
			"    i += k; j -= k;",
			"  }",
			"  return R;",
			"}"
		],
		"description": "manacher"
	},
	"FFT": {
		"prefix": "FFT",
		"body": [
			"typedef complex<double> C;",
			"int fft_n;",
			"vector<C> omega;",
			"",
			"int mod_pow(int x, int y = MOD - 2) {",
			"  int res = 1;",
			"  while (y > 0) {",
			"    if (y & 1) res = (res * x) % MOD;",
			"    x = (x * x) % MOD;",
			"    y >>= 1;",
			"  }",
			"  return res;",
			"}",
			"",
			"void init_fft(int n) {",
			"  fft_n = n;",
			"  omega.resize(n);",
			"  double angle = 2 * M_PI / n;",
			"  REP(i,n) {",
			"    omega[i] = C(cos(i * angle), sin(i * angle));",
			"  }",
			"}",
			"",
			"void fft(vector<C> & a) {",
			"  int n = a.size();",
			"  if (n == 1) return;",
			"  int half = n >> 1;",
			"  vector<C> even(half), odd(half);",
			"  for (int i = 0, j = 0; i < n; i += 2, ++j) {",
			"    even[j] = a[i];",
			"    odd[j] = a[i+1];",
			"  }",
			"  fft(even); fft(odd);",
			"  for (int i = 0, fact = fft_n / n; i < half; ++i) {",
			"    C twiddle = odd[i] * omega[i * fact];",
			"    a[i] = even[i] + twiddle;",
			"    a[i + half] = even[i] - twiddle;",
			"  }",
			"}",
			"",
			"vector<int> mul_fft(const vector<int> &a, const vector<int> &b) {",
			"  vector<int> res;",
			"  vector<C> fa(a.begin(), a.end()), fb(b.begin(), b.end());",
			"  int n = 1;",
			"  while (n < 2 * max (a.size(), b.size())) n <<= 1;",
			"  fa.resize(n); fb.resize(n);",
			"  init_fft(n);",
			"  fft(fa); fft(fb);",
			"  REP(i,n) fa[i] = conj(fa[i] * fb[i]);",
			"  fft(fa);",
			"  res.resize (n);",
			"  REP(i,n) {",
			"    res[i] = (int) (fa[i].real() / n + 0.5);",
			"  }",
			"  return res;",
			"}",
			"// vec hoge = mul_fft(a,b)で呼び出し",
			"// hoge[i]はΣa[k]*b[i-k]",
			"// a,bは1-indexedで取る(0があれば0に)"
		],
		"description": "高速フーリエ変換"
	},
	"EulerianTrail": {
		"prefix": "euler",
		"body": [
			"void make_trail(int no, vector<int> &trail) {",
			"  while(edge[no].size()) {",
			"    int v = edge[no].back();",
			"    edge[no].pop_back();",
			"    for (int to = 0; i < edge[v].size();++i) {",
			"      if (edge[v][i] == no) {",
			"        edge[v].erase(edge[v].begin() + i);",
			"        break;",
			"      }",
			"    }",
			"    make_trail(v, trail);",
			"  }",
			"  trail.push_back(no);",
			"}",
			"",
			"vector<int> EulerianTrail(const int s){",
			"  vector<int> res;",
			"  make_trail(s,res);",
			"  reverse(res.begin(),res.end());",
			"  return res;",
			"}"
		],
		"description": "オイラー路構築"
	},
	"next_index": {
		"prefix": "nxid",
		"body": [
			"//文字列Sのi文字目以降初めてアルファベットjが出現するindex。O(|S|*文字種)",
			"mat next_index(string &s){",
			"  int len = s.size();",
			"  mat nx(len,vec(26,INF));",
			"  REP(i,len-1) nx[i][s[i+1]-'a'] = i+1;",
			"  RREP(i,len-1) REP(j,26) nx[i][j] = min(nx[i][j],nx[i+1][j]);",
			"  return nx;",
			"}"
		],
		"description": "文字列内で次に文字が出現するindex前計算"
	},
	"bfs": {
		"prefix": "bfs",
		"body": [
			"vector<vector<int>> bfs(vector<string> &s){",
			"  int h = s.size(), w = s[0].size();",
			"  vector<vector<int>> tmp(h,vector<int>(w,-1));",
			"  queue<P> Q;",
			"  // ↓ここにqueueの初期化操作を書く(初期マスは０にする)",
			"",
			"  while(Q.size()){",
			"    P p = Q.front(); Q.pop();",
			"    REP(i,dx.size()){",
			"      int x = p.fs+dx[i], y = p.sc+dy[i];",
			"      if(range(x,0,h) && range(y,0,w) && tmp[x][y] == -1){ // 進めないマスを加える",
			"        tmp[x][y] = tmp[p.fs][p.sc]+1;",
			"        Q.push(P(x,y));",
			"      }",
			"    }",
			"  }",
			"  return tmp;",
			"}"
		],
		"description": "bfs"
	},
	"CHT": {
		"prefix": "cht",
		"body": [
			"template <typename T,T inf,bool isMin>",
			"struct ConvexHullTrick {",
			"  using P = pair<T, T>;",
			"  deque<P> L;",
			" ",
			"  inline T getY(const P &a,const T &x){",
			"    return a.first*x+a.second; ",
			"  }",
			" ",
			"  inline bool check(const P &a,const P &b,const P &c){",
			"    return (b.first-a.first)*(c.second-b.second)",
			"      >= (b.second-a.second)*(c.first-b.first);",
			"  }",
			"  ",
			"  void add(T a,T b){",
			"    if(!isMin) a*=-1,b*=-1;",
			"    P line(a,b);",
			"    if(!L.empty()&&L.back().first==a){",
			"      line.second=min(line.second,L.back().second);",
			"      L.pop_back();",
			"    }",
			"    while(L.size()>=2&&check(L[L.size()-2],L[L.size()-1],line)) L.pop_back();",
			"    L.emplace_back(line);    ",
			"  }",
			" ",
			"  T get(T x){",
			"    if(L.empty()) return isMin?inf:-inf;",
			"    int low=-1,high=L.size()-1;",
			"    while(low+1<high){",
			"      int mid=(low+high)>>1;",
			"      if(getY(L[mid],x)>=getY(L[mid+1],x)) low=mid;",
			"      else high=mid;",
			"    }",
			"    return (!isMin?-1:1)*getY(L[high],x);",
			"  }",
			"  ",
			"  T getMonotone(T x){",
			"    if(L.empty()) return isMin?inf:-inf;",
			"    while(L.size()>=2&&getY(L[0],x)>=getY(L[1],x)) L.pop_front();",
			"    return (!isMin?-1:1)*getY(L[0],x);",
			"  }",
			"};"
		],
		"description": "cht"
	},
	"sum": {
		"prefix": "sum",
		"body": [
			"//半開区間",
			"int sum(int x, int y, int s, int t, vector<vector<int>> &tmp){",
			"  return tmp[s][t]-tmp[s][y]-tmp[x][t]+tmp[x][y];",
			"}"
		],
		"description": "二次元累積和の総和"
	},
	"HLDecomposition": {
		"prefix": "HLD",
		"body": [
			"struct HLDecomposition {",
			"  int n,pos;",
			"  vector<vector<int> > G;",
			"  vector<int> vid, head, sub, par, dep, inv, type;",
			"  ",
			"  HLDecomposition(){}",
			"  HLDecomposition(int n):",
			"    n(n),pos(0),G(n),vid(n,-1),head(n),sub(n,1),",
			"    par(n,-1),dep(n,0),inv(n),type(n){}",
			"  ",
			"  void add_edge(int u, int v) {",
			"    G[u].push_back(v);",
			"    G[v].push_back(u);",
			"  }",
			" ",
			"  void build(vector<int> rs={0}) {",
			"    int c=0;",
			"    for(int r:rs){",
			"      dfs_sz(r);",
			"      head[r]=r;",
			"      dfs_hld(r,c++);",
			"    }",
			"  }",
			"  ",
			"  void dfs_sz(int v) {",
			"    for(int &u:G[v]){",
			"      if(u==par[v]) continue;",
			"      par[u]=v;",
			"      dep[u]=dep[v]+1;",
			"      dfs_sz(u);      ",
			"      sub[v]+=sub[u];      ",
			"      if(sub[u]>sub[G[v][0]]) swap(u,G[v][0]);",
			"    }",
			"  }",
			" ",
			"  void dfs_hld(int v,int c) {",
			"    vid[v]=pos++;",
			"    inv[vid[v]]=v;",
			"    type[v]=c;",
			"    for(int u:G[v]){",
			"      if(u==par[v]) continue;",
			"      head[u]=(u==G[v][0]?head[v]:u);",
			"      dfs_hld(u,c);",
			"    }    ",
			"  }",
			"  ",
			"  // for_each(vertex)",
			"  // [l,r] <- attention!!  ",
			"  template<typename F>",
			"  void for_each(int u, int v, const F& f) {",
			"    while(1){",
			"      if(vid[u]>vid[v]) swap(u,v);",
			"      f(max(vid[head[v]],vid[u]),vid[v]);",
			"      if(head[u]!=head[v]) v=par[head[v]];",
			"      else break;",
			"    }",
			"  }",
			" ",
			"  template<typename T,typename Q,typename F>",
			"  T for_each(int u,int v,T ti,const Q &q,const F &f){",
			"    T l=ti,r=ti;",
			"    while(1){",
			"      if(vid[u]>vid[v]){",
			"        swap(u,v);",
			"        swap(l,r);",
			"      }",
			"      l=f(l,q(max(vid[head[v]],vid[u]),vid[v]));",
			"      if(head[u]!=head[v]) v=par[head[v]];",
			"      else break;",
			"    }",
			"    return f(l,r);",
			"  }",
			"  ",
			"  // for_each(edge)",
			"  // [l,r] <- attention!!",
			"  template<typename F>",
			"  void for_each_edge(int u, int v,const F& f) {",
			"    while(1){",
			"      if(vid[u]>vid[v]) swap(u,v);",
			"      if(head[u]!=head[v]){",
			"        f(vid[head[v]],vid[v]);",
			"        v=par[head[v]];",
			"      }else{",
			"        if(u!=v) f(vid[u]+1,vid[v]);",
			"        break;",
			"      }",
			"    }",
			"  }",
			"  ",
			"  int lca(int u,int v){",
			"    while(1){",
			"      if(vid[u]>vid[v]) swap(u,v);",
			"      if(head[u]==head[v]) return u;",
			"      v=par[head[v]];",
			"    }",
			"  }",
			" ",
			"  int distance(int u,int v){",
			"    return dep[u]+dep[v]-2*dep[lca(u,v)];",
			"  }",
			"};"
		],
		"description": "HL分解"
	},
	"KMP": {
		"prefix": "kmp",
		"body": [
			"template < class T >",
			"vector< int > KMP(T s) {",
			"  int n = s.size();",
			"  vector< int > kmp(n + 1), mp(n + 1), res(n);",
			"  kmp[0] = mp[0] = -1;",
			"  int j = -1;",
			"  for(int i = 0; i < n; i++) {",
			"    while(j >= 0 && s[i] != s[j]) j = kmp[j];",
			"    kmp[i + 1] = mp[i + 1] = ++j;",
			"    if(i + 1 < n && s[i + 1] == s[j]) kmp[i + 1] = kmp[j];",
			"  }",
			"  for(int i = 0; i < n; i++) res[i] = mp[i+1];",
			"  return res;",
			"}"
		],
		"description": "KMP"
	},
	"inversion": {
		"prefix": "inversion",
		"body": [
			"//配列サイズは1e6まで",
			"//a[i]>a[j] なる i<jの組み合わせを求める",
			"const int NMAX = 1e6+10;",
			"vector<int> T(NMAX,0);",
			"int inversion(vector<int> &A, const int l, const int r) {",
			"  if(r <= l+1) return 0;",
			"  int cnt = 0;",
			"  const int m = (l+r)/2;",
			"  cnt += inversion(A,l,m) + inversion(A,m,r);",
			"",
			"  int i = l, j = m, k = 0, c = 0;",
			"  while(i < m && j < r){",
			"    if(A[j] < A[i]) { // 等しい値も転倒数に含む場合は A[j] <= A[i] とする",
			"      T[k++] = A[j++];",
			"      c++;",
			"    }",
			"    else{",
			"      T[k++] = A[i++];",
			"      cnt += c;",
			"    }",
			"  }",
			"",
			"  while(i < m){",
			"    T[k++] = A[i++];",
			"      cnt += c;",
			"  }",
			"",
			"  while(j < r) T[k++] = A[j++];",
			"",
			"  for(int t = l; t < r; ++t) A[t] = T[t-l];",
			"",
			"  return cnt;",
			"}"
		],
		"description": "転倒数"
	},
	"PartitionNumber": {
		"prefix": "part",
		"body": [
			"// pn.R(i,j) でi個をjグループで割り振る場合の数。 O(N^2)",
			"template<typename T> struct PartitionNumber{",
			"  int n;",
			"  vector<T> _P; vector<vector<T>> _PP, _Q, _R;",
			"  PartitionNumber(int _n){",
			"    n = _n;",
			"    _P.resize(n + 1);",
			"    _PP.resize(n + 1, vector<T>(n + 1));",
			"    _Q.resize(n + 1, vector<T>(n + 1));",
			"    _R.resize(n + 1, vector<T>(n + 1));",
			"",
			"    _Q[0][0] = 1;",
			"    FOR(i, 1, n + 1) FOR(j, 1, n + 1) {",
			"      _Q[i][j] += _Q[i - 1][j - 1];",
			"      if (j <= i) _Q[i][j] += _Q[i - j][j];",
			"      _Q[i][j] %= MOD;",
			"    }",
			"    FOR(i, 0, n + 1){",
			"      _R[i][0] = _Q[i][0];",
			"      FOR(j, 1, n + 1) _R[i][j] = _R[i][j - 1] + _Q[i][j];",
			"    }",
			"  }",
			"",
			"  int R(int i, int j){",
			"    assert(0 <= j and 0 <= i and j <= n and i <= n);",
			"    return _R[i][j] % MOD;",
			"  }",
			"};",
			"PartitionNumber<int> pn(1010);"
		],
		"description": "分割数"
	},
	"unionfind": {
		"prefix": "uf",
		"body": [
			"struct UnionFind {",
			"  private:",
			"  vector<int> child,tree;",
			"  vector<vector<int>> list;",
			"",
			"public:",
			"  UnionFind(int v) {",
			"    tree.resize(v);",
			"    list.resize(v);",
			"    REP(i,v) tree[i] = i, list[i].push_back(i);",
			"  }",
			"",
			"  int root(int i){",
			"    if(i == tree[i]){",
			"      REP(j,child.size()) tree[child[j]] = i;",
			"      child.clear(); ",
			"      return i;",
			"    }",
			"    else{",
			"      child.push_back(i);",
			"      return i = root(tree[i]);",
			"    }",
			"  }",
			"",
			"  int size(int i){",
			"    return list[root(i)].size();",
			"  }",
			"",
			"  vector<int> nodes(int no){",
			"    return list[root(no)];",
			"  }",
			"",
			"  bool unit(int x, int y){",
			"    x = root(x);",
			"    y = root(y);",
			"    if(x==y) return false;",
			"    if(list[x].size() < list[y].size()) swap(x,y);",
			"    for(int no:list[y]) list[x].emplace_back(no);",
			"    tree[y] = x;",
			"    return true;",
			"  }",
			"",
			"  bool isUnit(int x, int y){",
			"    return root(x) == root(y);",
			"  }",
			"};"
		],
		"description": "unionfind"
	},
	"部分永続unionfind": {
		"prefix": "UF",
		"body": [
			"class PartiallyPersistentUnionFindTree {",
			"public:",
			"  using size_type = std::uint_fast32_t;",
			" ",
			"private:",
			"  std::vector<std::pair<size_type, size_type>> tree;",
			"  std::vector<std::vector<std::pair<size_type, size_type>>> siz;",
			"  size_type global_count;",
			" ",
			"public:",
			"  PartiallyPersistentUnionFindTree(const size_type size)",
			"    : tree(size, std::make_pair(1, std::numeric_limits<size_type>::max())),",
			"      siz(size, std::vector<std::pair<size_type, size_type>>(",
			"      1, std::make_pair(0, 1))),",
			"    global_count(0) {}",
			"  size_type find(const size_type ver, size_type x) const {",
			"    assert(x < tree.size());",
			"    while (tree[x].second <= ver)",
			"      x = tree[x].first;",
			"    return x;",
			"  }",
			"  bool unit(size_type x, size_type y) {",
			"    assert(x < tree.size());",
			"    assert(y < tree.size());",
			"    ++global_count;",
			"    x = find(global_count, x);",
			"    y = find(global_count, y);",
			"    if (x == y)",
			"      return false;",
			"    if (tree[x].first < tree[y].first)",
			"      std::swap(x, y);",
			"    tree[x].first += tree[y].first;",
			"    siz[x].emplace_back(global_count, tree[x].first);",
			"    tree[y] = std::make_pair(x, global_count);",
			"    return true;",
			"  }",
			"  bool isUnit(const size_type ver, const size_type x, const size_type y) const {",
			"    assert(x < tree.size());",
			"    assert(y < tree.size());",
			"    return find(ver, x) == find(ver, y);",
			"  }",
			"  size_type size(const size_type ver, size_type x) const {",
			"    assert(x < tree.size());",
			"    x = find(ver, x);",
			"    return (std::lower_bound(siz[x].begin(), siz[x].end(),",
			"      std::make_pair(ver+1, static_cast<size_type>(0)))-1)",
			"      ->second;",
			"  }",
			"",
			"  size_type count() const { return global_count; }",
			"  size_type query(const size_type ver, size_type x, size_type y)const {",
			"    x = find(ver, x);",
			"    y = find(ver, y);",
			"    if (x == y) return size(ver, x);",
			"    return size(ver, x) + size(ver, y);",
			"  }",
			"};",
			"/*",
			"使い方",
			"宣言: PartiallyPersistentUnionFindTree uf(n);",
			"各クエリ　isUnit(ver,x,y) ver回目のunitでのx,yの連結判定",
			"*/"
		],
		"description": "部分永続unionfind"
	},
	"min_cost_flow": {
		"prefix": "min_cost_flow",
		"body": [
			"struct edge{int to,cap,cost,rev;};",
			"",
			"const int MAX_V = 3e5;",
			"int V;",
			"vector<edge> G[MAX_V];",
			"vector<int> h,dist,prevv(MAX_V),preve(MAX_V);",
			"",
			"void add_edge(int from, int to, int cap, int cost){",
			"  G[from].push_back((edge){to,cap,cost,G[to].size()});",
			"  G[to].push_back((edge){from,0,-cost,G[from].size()-1});",
			"}",
			"",
			"int min_cost_flow(int s, int t, int f){",
			"  int res = 0;",
			"  h.assign(V,0);",
			"  while(f > 0){",
			"    priority_queue<P,vector<P>,greater<P> > que;",
			"    dist.assign(V,INF);",
			"    dist[s] = 0;",
			"    que.push(P(0,s));",
			"    while(!que.empty()){",
			"      P p = que.top();",
			"      que.pop();",
			"      int v = p.sc;",
			"      if(dist[v] < p.fs) continue;",
			"      REP(i,G[v].size()){",
			"        edge &e = G[v][i];",
			"        if(e.cap > 0 && dist[e.to] > dist[v]+e.cost+h[v]-h[e.to]){",
			"          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];",
			"          prevv[e.to] = v;",
			"          preve[e.to] = i;",
			"          que.push(P(dist[e.to],e.to));",
			"        }",
			"      }",
			"    }",
			"    if(dist[t] == INF) return -1;",
			"    REP(v,V) h[v] += dist[v];",
			"    int d = f;",
			"    for(int v = t; v != s; v = prevv[v]) d = min(d,G[prevv[v]][preve[v]].cap);",
			"    f -= d;",
			"    res += d*h[t];",
			"    for(int v = t; v != s; v = prevv[v]){",
			"      edge &e = G[prevv[v]][preve[v]];",
			"      e.cap -= d;",
			"      G[v][e.rev].cap += d;",
			"    }",
			"  }",
			"  return res;",
			"}",
			"// Vを頂点数で更新する！！"
		],
		"description": "最小費用流"
	},
	"max_flow": {
		"prefix": "maxflow",
		"body": [
			"struct max_flow{",
			"  public:",
			"  struct edge {int to,cap,rev;};",
			"  int V;",
			"  vector<vector<edge>> G;",
			"  vector<int> level,iter;",
			"",
			"  max_flow(int v){",
			"    V = v; G.resize(v);",
			"  }",
			"",
			"  void add_edge(int from, int to, int cap){",
			"    G[from].push_back((edge){to,cap,G[to].size()});",
			"    G[to].push_back((edge){from,0,G[from].size()-1});",
			"  }",
			"",
			"  void bfs(int s){",
			"    level.assign(V,-1);",
			"    queue<int> que;",
			"    level[s] = 0;",
			"    que.push(s);",
			"    while(!que.empty()){",
			"      int v = que.front();",
			"      que.pop();",
			"      REP(i,G[v].size()){",
			"        edge &e = G[v][i];",
			"        if(e.cap > 0 && level[e.to] < 0){",
			"          level[e.to] = level[v] + 1;",
			"          que.push(e.to);",
			"        }",
			"      }",
			"    }",
			"  }",
			"",
			"  int dfs(int v, int t, int f){",
			"    if(v == t) return f;",
			"    for(int &i = iter[v]; i < G[v].size(); i++){",
			"      edge &e = G[v][i];",
			"      if(e.cap > 0 && level[v] < level[e.to]){",
			"        int d = dfs(e.to,t,min(f,e.cap));",
			"        if(d > 0){",
			"          e.cap -= d;",
			"          G[e.to][e.rev].cap += d;",
			"          return d;",
			"        }",
			"      }",
			"    }",
			"    return 0;",
			"  }",
			"",
			"  int run(int s, int t){",
			"    int flow = 0;",
			"    while(1){",
			"      bfs(s);",
			"      if(level[t] < 0) return flow;",
			"      iter.assign(V,0);",
			"      int tmp;",
			"      while((tmp = dfs(s,t,INF)) > 0){",
			"        flow += tmp;",
			"      }",
			"    }",
			"  }",
			"};",
			"// INFが大きすぎないか？"
		],
		"description": "最大流"
	},
	"isBip": {
		"prefix": "isBip",
		"body": [
			"const int NMAX = 1e5;",
			"vector<int> edge[NMAX],color(NMAX,0);",
			"",
			"bool isBip(int no){",
			"  if(color[no] == 0) color[no] = 1;",
			"  for(auto to:edge[no]){",
			"    if(color[no] == color[to]) return false;",
			"    else if(color[to] == 0){",
			"      color[to] = -color[no];",
			"      if(!isBip(to)) return false;",
			"    }",
			"  }",
			"  return true;",
			"}"
		],
		"description": "2部グラフ判定"
	},
	"bipartite_matching": {
		"prefix": "bipartite_matching",
		"body": [
			"const int MAX_V = 3e5;",
			"int V;",
			"vector<int> G[MAX_V],match,used(MAX_V,0);",
			"",
			"void add_edge(int u, int v){",
			"  G[u].pb(v);",
			"  G[v].pb(u);",
			"}",
			"",
			"bool dfs(int v){",
			"  used[v]++;",
			"  REP(i,G[v].size()){",
			"    int u = G[v][i], w = match[u];",
			"    if(w < 0 || !used[w] && dfs(w)){",
			"      match[v] = u;",
			"      match[u] = v;",
			"      return true;",
			"      }",
			"    }",
			"  return false;",
			"}",
			"",
			"int bipartite_matching(){",
			"  int res = 0;",
			"  match.assign(V,-1);",
			"  REP(s,V){",
			"    if(match[s] < 0){",
			"      used.assign(V,0);",
			"      if(dfs(s)) res++;",
			"      }",
			"    }",
			"  return res;",
			"}",
			"// Vを頂点数に更新する！！"
		],
		"description": "2部マッチング"
	},
	"t_sort": {
		"prefix": "tsort",
		"body": [
			"const int NMAX = 2e5+10;",
			"vector<int> g[NMAX]; // g[i][j]-> iからjの有向辺",
			"int h[NMAX]; //h[i]-> iの入り次数",
			"int v,e;",
			"",
			"vector<int> t_sort(){",
			"  stack<int> st;",
			"  REP(i, v) if(h[i] == 0) st.push(i);",
			"  vector<int> res;",
			"  while(st.size()) {",
			"    int i = st.top(); st.pop();",
			"    res.push_back(i);",
			"    for(auto& j: g[i]) {",
			"      h[j]--;",
			"      if(h[j] == 0) st.push(j);",
			"    }",
			"  }",
			"  return res;",
			"}",
			"// 頂点数v,　辺の本数e",
			"// res.size()がvで無いなら閉路がある"
		],
		"description": "トポロジカルソート"
	},
	"maximum_rectangle": {
		"prefix": "maximum_rectangle",
		"body": [
			"int maximum_rectangle(vec &h) {",
			"  int n = h.size();",
			"  stack<int> st;",
			"  vec L(n), R(n);",
			"  REP(i,n){",
			"    while (st.size() && h[st.top()] >= h[i]) st.pop();",
			"    L[i] = st.size() ? (st.top() + 1) : 0;",
			"    st.push(i);",
			"  }",
			"  while (st.size()) st.pop();",
			"  RREP(i,n){",
			"    while (st.size() > 0 && h[st.top()] >= h[i]) st.pop();",
			"    R[i] = st.size() ? st.top() : n;",
			"    st.push(i);",
			"  }",
			"  int res = 0;",
			"  REP(i,n){",
			"    res = max(res,h[i]*(R[i]-L[i]));",
			"  }",
			"  return res;",
			"}"
		],
		"description": "ヒストグラム内の最大長方形"
	},
	"scc": {
		"prefix": "scc",
		"body": [
			"struct SCC{",
			"public:",
			"  int V,cnt = 0;",
			"  mat G,rG,edge;",
			"  vec vs,cmp,used;",
			"",
			"  SCC(int node_size) : V(node_size), G(V), rG(V), cmp(V), used(V,0) {}",
			"",
			"  void add_edge(int from, int to) {",
			"    G[from].push_back(to);",
			"    rG[to].push_back(from);",
			"  }",
			"",
			"  void dfs(int u) {",
			"    used[u]++;",
			"    for (int v:G[u]) if(!used[v]) dfs(v);",
			"    vs.push_back(u);",
			"  }",
			"",
			"  void dfs(int u, int k) {",
			"    used[u]++;",
			"    cmp[u] = k;",
			"    for (int v:rG[u]) if(!used[v]) dfs(v,k);",
			"  }",
			"",
			"  int solve(){",
			"    REP(i,V) if(!used[i]) dfs(i); ",
			"    REP(i,V) used[i] = 0;",
			"    RREP(i,vs.size()) if(!used[vs[i]]) dfs(vs[i],cnt++);",
			"    return cnt;",
			"  }",
			"",
			"  void make_graph(){",
			"    edge.resize(cnt);",
			"    REP(i,V){",
			"      for(int v:G[i]){",
			"        if(cmp[i] < cmp[v]) edge[cmp[i]].push_back(cmp[v]);",
			"      }",
			"    }",
			"  }",
			"  void clear(){",
			"    vec().swap(vs);",
			"    vec().swap(used);",
			"    mat().swap(G);",
			"    mat().swap(rG);",
			"  }",
			"};"
		],
		"description": "強連結成分分解"
	},
	"binary_search": {
		"prefix": "bs",
		"body": [
			"int ng = $1, ok = $2;",
			"while (abs(ng-ok)>1) {",
			"  int mid = ng+(ok-ng)/2;",
			"  (check(mid)?ok:ng) = mid;",
			"}"
		],
		"description": "にぶたん"
	},
	"segment_tree_RMQ": {
		"prefix": "segrmq",
		"body": [
			"struct SegmentTree {",
			"  private:",
			"    int n;",
			"    vector<int> node;",
			"",
			"public:",
			"  SegmentTree(vector<int> v) {",
			"    int sz = (int)v.size();",
			"    n = 1; while(n < sz) n *= 2;",
			"    node.resize(2*n-1);",
			"",
			"    REP(i,sz) node[i+n-1] = v[i];",
			"    RREP(i,n-1) node[i] = min(node[i*2+1],node[i*2+2]); //最大値ならmax",
			"  }",
			"",
			"  // 0_indexedでk番目の要素をaに変更",
			"  void update(int k, int a){",
			"    k += n-1;",
			"    node[k] = a;",
			"    while(k > 0){",
			"      k = (k-1) / 2;",
			"      node[k] = min(node[k*2+1],node[k*2+2]); //最大値ならmax",
			"    }",
			"  }",
			"",
			"  // 半開区間[l,r)から、[a,b)に対するクエリ。",
			"  int query(int a, int b, int k=0, int l=0, int r=-1){",
			"    if(r < 0) r = n;",
			"    if(r <= a || b <= l) return INF; // 最大値なら-INF",
			"    if(a <= l && r <= b) return node[k];",
			"    else{",
			"      int vl = query(a,b,k*2+1,l,(l+r)/2);",
			"      int vr = query(a,b,k*2+2,(l+r)/2,r);",
			"      return min(vl,vr); //最大値ならmax",
			"    }",
			"  }",
			"};"
		],
		"description": "セグ木RMQ"
	},
	"segment_tree_RSQ": {
		"prefix": "segrsq",
		"body": [
			"struct SegmentTree {",
			"  private:",
			"    int n;",
			"    vector<int> node;",
			"",
			"public:",
			"  SegmentTree(vector<int> v) {",
			"    int sz = (int)v.size();",
			"    n = 1; while(n < sz) n *= 2;",
			"    node.resize(2*n-1);",
			"",
			"    REP(i,sz) node[i+n-1] = v[i];",
			"    RREP(i,n-1) node[i] = node[i*2+1]+node[i*2+2];",
			"  }",
			"",
			"  // 0_indexedでk番目の要素をaに変更",
			"  void update(int k, int a){",
			"    k += n-1;",
			"    node[k] = a;",
			"    while(k > 0){",
			"      k = (k-1) / 2;",
			"      node[k] = node[k*2+1]+node[k*2+2];",
			"    }",
			"  }",
			"",
			"  // 半開区間[l,r)から、[a,b)に対するクエリ。",
			"  int query(int a, int b, int k=0, int l=0, int r=-1){",
			"    if(r < 0) r = n;",
			"    if(r <= a || b <= l) return 0;",
			"    if(a <= l && r <= b) return node[k];",
			"    else{",
			"      int vl = query(a,b,k*2+1,l,(l+r)/2);",
			"      int vr = query(a,b,k*2+2,(l+r)/2,r);",
			"      return vl+vr;",
			"    }",
			"  }",
			"};"
		],
		"description": "セグ木RSQ"
	},
	"lazy_segment_tree_abst": {
		"prefix": "lazy",
		"body": [
			"// //高速化",
			"// template <typename T,typename E, typename F, typename G, typename H>",
			"// struct SegmentTree{",
			"//   // using F = function<T(T,T)>;",
			"//   // using G = function<T(T,E)>;",
			"//   // using H = function<E(E,E)>;",
			"//   ~~~",
			"// };",
			"//   SegmentTree<int, int, decltype(f), decltype(g), decltype(h)> seg(f,g,h,ti,ei);",
			"template <typename T,typename E>",
			"struct SegmentTree{",
			"  using F = function<T(T,T)>;",
			"  using G = function<T(T,E,int)>;",
			"  using H = function<E(E,E)>;",
			"  int n;",
			"  F f;",
			"  G g;",
			"  H h;",
			"  T ti;",
			"  E ei;",
			"  vector<T> dat;",
			"  vector<E> laz;",
			"  SegmentTree(F f,G g,H h,T ti,E ei):",
			"    f(f),g(g),h(h),ti(ti),ei(ei){}",
			"",
			"  void init(int n_){",
			"    n=1;",
			"    while(n<n_) n<<=1;",
			"    dat.assign((n<<1)-1,ti);",
			"    laz.assign((n<<1)-1,ei);",
			"  }",
			"  void build(const vector<T> &v){",
			"    int n_=v.size();",
			"    init(n_);",
			"    for(int i=0;i<n_;i++) dat[n+i-1]=v[i];",
			"    for(int i=n-2;i>=0;i--)",
			"      dat[i]=f(dat[(i<<1)+2],dat[(i<<1)|1]);",
			"  }",
			"  void eval(int k,int l,int r){",
			"    if(laz[k]==ei)return;",
			"    dat[k] = g(dat[k], laz[k], r-l);",
			"    if(r-l>1){",
			"      laz[(k<<1)|1] = h(laz[(k<<1)|1], laz[k]);",
			"      laz[(k<<1)+2] = h(laz[(k<<1)+2], laz[k]);",
			"    }",
			"    laz[k]=ei;",
			"  }",
			"",
			"  void update(int a, int b, E x,int k=0,int l=0,int r=-1){",
			"    if(r<0)r=n;",
			"    eval(k,l,r);",
			"    if(r<=a||b<=l)return;",
			"    if(a<=l&&r<=b){",
			"      laz[k] = h(laz[k], x);",
			"      eval(k,l,r);",
			"    }",
			"    else {",
			"      update(a,b,x,(k<<1)|1,l,(l+r)/2);",
			"      update(a,b,x,(k<<1)+2,(l+r)/2,r);",
			"      dat[k]=f(dat[(k<<1)|1], dat[(k<<1)+2]);",
			"    }",
			"  }",
			"",
			"  T query(int a,int b,int k=0,int l=0,int r=-1){",
			"    if(r<0)r=n;",
			"    eval(k,l,r);",
			"    if(r<=a||b<=l)return ti;",
			"    if(a<=l&&r<=b)return dat[k];",
			"    T xl=query(a,b,(k<<1)|1,l,(l+r)/2);",
			"    T xr=query(a,b,(k<<1)+2,(l+r)/2,r);",
			"    return f(xl, xr);",
			"  }",
			"",
			"  //lower_find(l,r,fanc): fancを満たす区間[0,id)なるidの最小値を返す. ng < okのとき",
			"  template<typename C>",
			"  int lower_find(int a, int b, C &check, T x, int k=1, int l=0, int r=-1){",
			"    if(r<0)r=n;",
			"    if(!check(f(x,dat[k]))||r<=a||b<=l)return -1;",
			"    if(r-l==1)return l;",
			"    int xl = lower_find(a,b,check,x,(k<<1),l,(l+r)/2);",
			"    if(xl>=0)return xl;",
			"    x = f(x,dat[(k<<1)]);",
			"    return lower_find(a,b,check,x,(k<<1)|1,(l+r)/2,r);",
			"  }",
			"  template<typename C>",
			"  int lower_find(int a, int b, C &check){",
			"    T x=ti;",
			"    return lower_find(a,b,check,x);",
			"  }",
			"",
			"  //upper_find(l,r,fanc): fancを満たす区間[0,id)なるidの最小値を返す. ok < ngのとき",
			"  template<typename C>",
			"  int upper_find(int a, int b, C &check, T x, int k=2, int l=0, int r=-1){",
			"    if(r<0)r=n;",
			"    if(r<=a||b<=l)return -1;",
			"    if(r-l==1)return l;",
			"    if(check(f(x,dat[k]))){",
			"      int xr = upper_find(a,b,check,f(x,dat[k]),((k+1)<<1),(l+r)/2,r);",
			"      if(xr>=0)return xr;",
			"    }",
			"    return upper_find(a,b,check,x,(k<<1),l,(l+r)/2);",
			"  }",
			"  template<typename C>",
			"  int upper_find(int a, int b, C &check){",
			"    T x=ti;",
			"    return upper_find(a,b,check,x);",
			"  }",
			"};",
			"",
			"//ex) RAQ & RSQ",
			"//auto f = [](int a, int b){return a+b;};",
			"//auto g = [](int a, int b, int len){return a+b*len;};",
			"//auto h = [](int a, int b){return a+b;};",
			"",
			"//ex) RAQ & RMQ",
			"//auto f = [](int a, int b){return min(a,b);};",
			"//auto g = [](int a, int b, int len){return a+b;};",
			"//auto h = [](int a, int b){return a+b;};"
		],
		"description": "抽象遅延セグ木"
	},
	"lazy_segment_tree_RSQ": {
		"prefix": "lazy_seg",
		"body": [
			"struct LazySegmentTree {",
			"  private:",
			"    int n;",
			"    vector<int> node, lazy_add, lazy_update;",
			"",
			"public:",
			"  LazySegmentTree(vector<int> v) {",
			"    int sz = (int)v.size();",
			"    n = 1; while(n < sz) n *= 2;",
			"    node.resize(2*n-1);",
			"    lazy_add.resize(2*n-1, 0);",
			"    lazy_update.resize(2*n-1, -INF);",
			"",
			"    REP(i,sz) node[i+n-1] = v[i];",
			"    RREP(i,n-1) node[i] = node[i*2+1] + node[i*2+2];",
			"  }",
			"",
			"  void eval(int k, int l, int r) {",
			"    if(lazy_add[k] != 0) {",
			"      node[k] += lazy_add[k];",
			"      if(r - l > 1) {",
			"        lazy_add[2*k+1] += lazy_add[k] / 2;",
			"        lazy_add[2*k+2] += lazy_add[k] / 2;",
			"      }",
			"      lazy_add[k] = 0;",
			"    }",
			"    if(lazy_update[k] != -INF) {",
			"      node[k] = (r-l)*lazy_update[k];",
			"      if(r - l > 1) {",
			"        lazy_update[2*k+1] = lazy_update[k];",
			"        lazy_update[2*k+2] = lazy_update[k];",
			"      }",
			"      lazy_update[k] = -INF;",
			"    }",
			"  }",
			"",
			"  void add(int a, int b, int x, int k=0, int l=0, int r=-1) {",
			"    if(r < 0) r = n;",
			"    eval(k, l, r);",
			"    if(b <= l || r <= a) return;",
			"    if(a <= l && r <= b) {",
			"      lazy_add[k] += (r - l) * x;",
			"      eval(k, l, r);",
			"    }",
			"    else {",
			"      add(a, b, x, 2*k+1, l, (l+r)/2);",
			"      add(a, b, x, 2*k+2, (l+r)/2, r);",
			"      node[k] = node[2*k+1] + node[2*k+2];",
			"    }",
			"  }",
			"",
			"  void update(int a, int b, int x, int k=0, int l=0, int r=-1) {",
			"    if(r < 0) r = n;",
			"    eval(k, l, r);",
			"    if(b <= l || r <= a) return;",
			"    if(a <= l && r <= b) {",
			"      lazy_update[k] = x;",
			"      eval(k, l, r);",
			"    }",
			"    else {",
			"      update(a, b, x, 2*k+1, l, (l+r)/2);",
			"      update(a, b, x, 2*k+2, (l+r)/2, r);",
			"      node[k] = node[2*k+1] + node[2*k+2];",
			"    }",
			"  }",
			"",
			"  int query(int a, int b, int k=0, int l=0, int r=-1) {",
			"    if(r < 0) r = n;",
			"    eval(k, l, r);",
			"    if(b <= l || r <= a) return 0;",
			"    if(a <= l && r <= b) return node[k];",
			"    int vl = query(a, b, 2*k+1, l, (l+r)/2);",
			"    int vr = query(a, b, 2*k+2, (l+r)/2, r);",
			"    return vl + vr;",
			"  }",
			"};"
		],
		"description": "遅延RSQ"
	},
	"segment_tree_abst": {
		"prefix": "seg",
		"body": [
			"template <typename T>",
			"struct SegmentTree{",
			"  using F = function<T(T,T)>;",
			"  int n;",
			"  F f;",
			"  T ti;",
			"  vector<T> dat;",
			"  SegmentTree(){};",
			"  SegmentTree(F f,T ti):f(f),ti(ti){}",
			"  void init(int n_){",
			"    n=1;",
			"    while(n<n_) n<<=1;",
			"    dat.assign(n<<1,ti);",
			"  }",
			"  void build(const vector<T> &v){",
			"    int n_=v.size();",
			"    init(n_);",
			"    for(int i=0;i<n_;i++) dat[n+i]=v[i];",
			"    for(int i=n-1;i;i--)",
			"      dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);",
			"  }",
			"  void update(int k,T x){",
			"    dat[k+=n]=x;",
			"    while(k>>=1)",
			"      dat[k]=f(dat[(k<<1)|0],dat[(k<<1)|1]);",
			"  }",
			"  void add(int k,T x){",
			"    dat[k+=n]+=x;",
			"    while(k>>=1)",
			"      dat[k]=f(dat[(k<<1)|0],dat[(k<<1)|1]);",
			"  }",
			"  T query(int a,int b){",
			"    T vl=ti,vr=ti;",
			"    for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {",
			"      if(l&1) vl=f(vl,dat[l++]);",
			"      if(r&1) vr=f(dat[--r],vr);",
			"    }",
			"    return f(vl,vr);",
			"  }",
			"  //lower_find(l,r,fanc): fancを満たす区間[0,id)なるidの最小値を返す. ng < okのとき",
			"  template<typename C>",
			"  int lower_find(int a, int b, C &check, T x, int k=1, int l=0, int r=-1){",
			"    if(r<0)r=n;",
			"    if(!check(f(x,dat[k]))||r<=a||b<=l)return -1;",
			"    if(r-l==1)return l;",
			"    int xl = lower_find(a,b,check,x,(k<<1),l,(l+r)/2);",
			"    if(xl>=0)return xl;",
			"    x = f(x,dat[(k<<1)]);",
			"    return lower_find(a,b,check,x,(k<<1)|1,(l+r)/2,r);",
			"  }",
			"  template<typename C>",
			"  int lower_find(int a, int b, C &check){",
			"    T x=ti;",
			"    return lower_find(a,b,check,x);",
			"  }",
			"",
			"  //upper_find(l,r,fanc): fancを満たす区間[0,id)なるidの最小値を返す. ok < ngのとき",
			"  template<typename C>",
			"  int upper_find(int a, int b, C &check, T x, int k=2, int l=0, int r=-1){",
			"    if(r<0)r=n;",
			"    if(r<=a||b<=l)return -1;",
			"    if(r-l==1)return l;",
			"    if(check(f(x,dat[k]))){",
			"      int xr = upper_find(a,b,check,f(x,dat[k]),((k+1)<<1),(l+r)/2,r);",
			"      if(xr>=0)return xr;",
			"    }",
			"    return upper_find(a,b,check,x,(k<<1),l,(l+r)/2);",
			"  }",
			"  template<typename C>",
			"  int upper_find(int a, int b, C &check){",
			"    T x=ti;",
			"    return upper_find(a,b,check,x);",
			"  }",
			"};"
		],
		"description": "抽象セグ木"
	},
	"Centroid": {
		"prefix": "centroid",
		"body": [
			"struct Centroid{",
			"  vector<int> sz,dead;",
			"  vector<vector<int> > edge;",
			"  Centroid(){}",
			"  Centroid(int n):sz(n,1),dead(n,0),edge(n){}",
			" ",
			"  void add_edge(int u,int v){",
			"    edge[u].emplace_back(v);",
			"    edge[v].emplace_back(u);",
			"  }",
			" ",
			"  int dfs(int v,int p){",
			"    sz[v]=1;",
			"    for(int u:edge[v])",
			"      if(u!=p&&!dead[u]) sz[v]+=dfs(u,v);",
			"    return sz[v];",
			"  }",
			" ",
			"  void find(int v,int p,int tmp,vector<int> &cs) {",
			"    int ok=1;",
			"    for (int u:edge[v]){",
			"      if(u==p||dead[u]) continue;",
			"      find(u,v,tmp,cs);",
			"      ok&=(sz[u]<=tmp/2);",
			"    }",
			"    ok&=(tmp-sz[v]<=tmp/2);",
			"    if(ok) cs.push_back(v);",
			"  }",
			" ",
			"  vector<int> build(int r) {",
			"    int tmp=dfs(r,-1);",
			"    vector<int> cs;",
			"    find(r,-1,tmp,cs);",
			"    return cs;",
			"  }",
			" ",
			"  void disable(int v){",
			"    dead[v]=1;",
			"  }",
			" ",
			"  void enable(int v){",
			"    dead[v]=0;",
			"  }",
			" ",
			"  int alive(int v){",
			"    return !dead[v];",
			"  }",
			"};"
		],
		"description": "木の重心分解"
	},
	"素因数分解・素数判定": {
		"prefix": "prime",
		"body": "struct fastprime\n{\n  vector<int> sieve;\n  int sieve_index;\n  fastprime()\n  {\n    sieve_index = 1'000'000;\n    sieve = sieve_init(sieve_index);\n    // 10^5 10 ms\n    // 10^6 30 ms\n    // 10^7 500ms\n  }\n  fastprime(int x)\n  {\n    sieve_index = x;\n    sieve = sieve_init(x);\n  }\n  vector<int> sieve_init(int x) // エラトステネスの篩 O(NloglohN)\n  {\n    x += 10;\n    vector<int> res(x);\n    rep(i, x) res[i] = i;\n    for (int i = 2; i < x; i++)\n      if (res[i] == i)\n        for (int j = i; j < x; j += i)\n          if (res[i] == i)\n            res[j] = i;\n    return res;\n  }\n  map<int, int> fact(int x) // 素因数分解 O(logN)\n  {\n    map<int, int> mp;\n    while (x != 1)\n    {\n      mp[sieve[x]]++;\n      x /= sieve[x];\n    }\n    return mp;\n  }\n  bool isPrime(int x) // 素数判定 O(1) or O(sqrtN)\n  {\n    if (x < sieve_index){\n      return (sieve[x] == x);\n    }\n    else\n      for (int i = 2; i * i < x; i++)\n        if (sieve[i] == i && x % sieve[i] == 0)\n          return false;\n    return true;\n  }\n};",
		"description": ""
	},
	"Warshall–Floyd": {
		"prefix": "war",
		"body": [
			"vector<int> dist[n];",
			"REP(i,n) dist[i].assign(n,INF);",
			"",
			"REP(i,n) dist[i][i] = 0;",
			"",
			"REP(k,n){",
			"  REP(i,n){",
			"    REP(j,n){",
			"      dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);",
			"    }",
			"  }",
			"}"
		],
		"description": "ワーシャルフロイト"
	},
	"LIS": {
		"prefix": "LIS",
		"body": [
			"int LIS(const vector<int> &v) {",
			"  int n = v.size();",
			"  vector<int> dp(n, INF);",
			"  REP(i,n) *lower_bound(dp.begin(), dp.end(), v[i]) = v[i];",
			"  return find(dp.begin(), dp.end(), INF) - dp.begin();",
			"}"
		],
		"description": "最長増加部分列"
	},
	"TwoEdgeConnectedComponent": {
		"prefix": "tecc",
		"body": [
			"struct LowLink {",
			"  set<pair<int, int>> bridge;",
			"  vector<int> articulation, ord, low;",
			"  vector<bool> used;",
			"  vector<vector<int>> g;",
			"  int n, k = 0;",
			"  LowLink(const vector<vector<int>> &g) : g(g) {",
			"    n = g.size();",
			"    ord.resize(n, 0);",
			"    low.resize(n, 0);",
			"    used.resize(n, false);",
			"  }",
			"  void dfs(int u, int prev) {",
			"    used[u] = true;",
			"    ord[u] = k++;",
			"    low[u] = ord[u];",
			"    bool is_articulation = false;",
			"    int cnt = 0;",
			"    for (auto v : g[u]) if (v != prev) {",
			"      if (!used[v]) {",
			"        cnt ++;",
			"        dfs(v, u);",
			"        low[u] = min(low[u], low[v]);",
			"        if (low[v] > ord[u]) {",
			"          bridge.emplace(min(u, v), max(u, v));",
			"        } ",
			"        if (prev != -1 && low[v] >= ord[u]) {",
			"          is_articulation = true;",
			"        }",
			"      } else {",
			"        low[u] = min(low[u], ord[v]);",
			"      }",
			"    }",
			"    if (prev == -1 && cnt > 1) is_articulation = true;",
			"    if (is_articulation) articulation.push_back(u);",
			"  }",
			"};",
			" ",
			"struct TwoEdgeConnectedComponent {",
			"  int n;",
			"  vector<vector<int>> g, tree;",
			"  vector<int> cmp,sz;",
			"  TwoEdgeConnectedComponent(){};",
			"  TwoEdgeConnectedComponent(const vector<vector<int>> &g) : g(g) {",
			"    n = (int) g.size();",
			"    cmp.assign(n, -1);",
			"  }",
			"  void build() {",
			"    LowLink lnk(g);",
			"    lnk.dfs(0, -1);",
			"    int k = 0;",
			"    function<void (int, int)> dfs = [&](int u, int prev) {",
			"      cmp[u] = k;",
			"      for (auto v : g[u]) if (cmp[v] == -1 && lnk.bridge.count({min(u, v), max(u, v)}) == 0) {",
			"        dfs(v, u);",
			"      }",
			"    };",
			"    for (int i = 0; i < n; i ++) if (cmp[i] == -1) {",
			"      dfs(i, -1);",
			"      k ++;",
			"    }",
			"    tree.resize(k);",
			"    sz.assign(k,0);",
			"    for(int i = 0; i < n; i++) sz[cmp[i]]++;",
			"    for (auto e : lnk.bridge) {",
			"      tree[cmp[e.first]].push_back(cmp[e.second]);",
			"      tree[cmp[e.second]].push_back(cmp[e.first]);",
			"    }",
			"  }",
			"};"
		],
		"description": "二重辺連結成分分解"
	},
	"ChineseRem": {
		"prefix": "chinese",
		"body": [
			"inline int mod(int a, int m) {",
			"  return (a % m + m) % m;",
			"}",
			"",
			"int extGcd(int a, int b, int &p, int &q) {",
			"  if (b == 0) { p = 1; q = 0; return a; }",
			"  int d = extGcd(b, a%b, q, p);",
			"  q -= a/b * p;",
			"  return d;",
			"}",
			"",
			"pair<int,int> ChineseRem(int b1, int m1, int b2, int m2) {",
			"  int p,q;",
			"  int d = extGcd(m1, m2, p, q);",
			"  if ((b2 - b1) % d != 0) return make_pair(0, -1);",
			"  int m = m1 * (m2/d);",
			"  int tmp = (b2 - b1) / d * p % (m2/d);",
			"  int r = mod(b1 + m1 * tmp, m);",
			"  return make_pair(r, m);",
			"}"
		],
		"description": "中国剰余定理"
	},
	"mod_set": {
		"prefix": "modset",
		"body": [
			"void add(int &a, int b){",
			"  a = ((a+b) % MOD + MOD) % MOD;",
			"}",
			"",
			"inline int mul(int a, int b) {",
			"    add(a,0); add(b,0);",
			"    #if !defined(_WIN32) || defined(_WIN64)",
			"      return (int) ((long long) a * b % MOD);",
			"    #endif",
			"      unsigned long long x = (long long) a * b;",
			"      unsigned xh = (unsigned) (x >> 32), xl = (unsigned) x, d, m;",
			"      asm(",
			"        \"divl %4; \\n\\t\"",
			"        : \"=a\" (d), \"=d\" (m)",
			"        : \"d\" (xh), \"a\" (xl), \"r\" (MOD)",
			"      );",
			"      return m;",
			"}",
			"",
			"inline int modpow(int a, long long b) {",
			"  int res = 1;",
			"  while (b > 0) {",
			"    if (b & 1) {",
			"      res = mul(res, a);",
			"      }",
			"      a = mul(a, a);",
			"      b >>= 1;",
			"  }",
			"  return res;",
			"}",
			"",
			"inline int inv(int a) {",
			"    a %= MOD;",
			"    if (a < 0) a += MOD;",
			"    int b = MOD, u = 0, v = 1;",
			"    while (a) {",
			"      int t = b / a;",
			"      b -= t * a; swap(a, b);",
			"      u -= t * v; swap(u, v);",
			"    }",
			"    assert(b == 1);",
			"    if (u < 0) u += MOD;",
			"    return u;",
			"}"
		],
		"description": "MODいろいろ"
	},
	"convex_hull": {
		"prefix": "convex",
		"body": [
			"int det(P x,P y){",
			"  return x.fs*y.sc-x.sc*y.fs;",
			"}",
			"P sub(P x,P y){",
			"  return P(x.first-y.first, x.second-y.second);",
			"}",
			"",
			"vector<P> Convex_Hull(vector<P>& p){",
			"  int n = p.size(), k = 0;",
			"  sort(p.begin(),p.end());",
			"  vector<P> q(2*n);",
			"  //下側凸包",
			"  REP(i,n){",
			"    while(k > 1 && det(sub(q[k-1],q[k-2]),sub(p[i],q[k-1])) <= 0) k--;",
			"    q[k++] = p[i];",
			"  }",
			"  //上側凸包",
			"  RREP(i,n-1){",
			"    int t = k;",
			"    while(k > t && det(sub(q[k-1],q[k-2]),sub(p[i],q[k-1])) <= 0) k--;",
			"    q[k++] = p[i];",
			"  }",
			"  q.resize(k);",
			"  return q;",
			"}"
		],
		"description": "凸包"
	},
	"Rolling_Hash": {
		"prefix": "roll",
		"body": [
			"template<class Z> Z rng(Z a, Z b) {",
			"  static mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());",
			"  return uniform_int_distribution<Z>(a, b - 1)(mt);",
			"}",
			" ",
			"struct RollingHash {",
			"  static constexpr uint64_t P0 = 4e9 + 7;",
			"  static constexpr uint64_t P1 = 4e9 + 9;",
			"  static uint64_t B0;",
			"  static uint64_t B1;",
			"  static vector<uint64_t> powB0;",
			"  static vector<uint64_t> powB1;",
			"  int n;",
			"  vector<uint64_t> h0;",
			"  vector<uint64_t> h1;",
			"  void init(string s){",
			"    n = s.size();",
			"    h0.resize(n+1); h1.resize(n+1);",
			"    for (int i = 0; i < n; ++i) {",
			"      h0[i + 1] = (h0[i] * B0 + s[i]) % P0;",
			"      h1[i + 1] = (h1[i] * B1 + s[i]) % P1;",
			"    }",
			"    while (powB0.size() <= n) {",
			"      powB0.push_back(powB0.back() * B0 % P0);",
			"      powB1.push_back(powB1.back() * B1 % P1);",
			"    }",
			"  }",
			"  void add(char in) {",
			"      h0.push_back((h0.back() * B0 + in) % P0);",
			"      h1.push_back((h1.back() * B1 + in) % P1);",
			"      powB0.push_back(powB0.back() * B0 % P0);",
			"      powB1.push_back(powB1.back() * B1 % P1);",
			"  }",
			"  uint64_t get0(int l, int r) { return (h0[r] + (P0 - h0[l]) * powB0[r - l]) % P0; }",
			"  uint64_t get1(int l, int r) { return (h1[r] + (P1 - h1[l]) * powB1[r - l]) % P1; }",
			"  pair<uint64_t, uint64_t> get(int l, int r) {",
			"      pair<uint64_t, uint64_t> a;",
			"      a.first = get0(l, r);",
			"      a.second = get1(l, r);",
			"      return a;",
			"  }",
			"  bool match(int l0, int r0, int l1, int r1) {",
			"    return get0(l0, r0) == get0(l1, r1) and get1(l0, r0) == get1(l1, r1);",
			"  }",
			"};",
			"uint64_t RollingHash::B0 = rng<unsigned>(1, RollingHash::P0);",
			"uint64_t RollingHash::B1 = rng<unsigned>(1, RollingHash::P1);",
			"vector<uint64_t> RollingHash::powB0{1};",
			"vector<uint64_t> RollingHash::powB1{1};"
		],
		"description": "Rolling_Hash"
	},
	"BigInt": {
		"prefix": "bint",
		"body": [
			"const int DEFAULT_SIZE = 1000;",
			"struct Bigint : vector<long long> {",
			"    static const long long BASE = 100000000;",
			"    static const int BASE_DIGIT = 8;",
			"    int sign;",
			"    ",
			"    Bigint() : vector<long long>(1, 0) { sign = 1; }",
			"    Bigint(long long num) : vector<long long>(DEFAULT_SIZE, 0) {",
			"        sign = 1; if (num < 0) sign = -1, num = -num;",
			"        (*this)[0] = num;",
			"        (*this).normalize();",
			"    }",
			"    Bigint(int SIZE, long long num) : vector<long long>(SIZE, 0) {",
			"        sign = 1; if (num < 0) sign = -1, num = -num;",
			"        (*this)[0] = num;",
			"        (*this).normalize();",
			"    }",
			"    ",
			"    Bigint& normalize() {",
			"        long long c = 0;",
			"        for (int i = 0;; ++i) {",
			"            if (i >= (*this).size()) (*this).push_back(0);",
			"            if ((*this)[i] < 0 && i+1 >= (*this).size()) (*this).push_back(0);",
			"            while ((*this)[i] < 0) { (*this)[i+1] -= 1; (*this)[i] += BASE; }",
			"            long long a = (*this)[i] + c;",
			"            (*this)[i] = a % BASE;",
			"            c = a / BASE;",
			"            if (c == 0 && i == (*this).size()-1) break;",
			"        }",
			"        return (*this);",
			"    }",
			"    ",
			"    inline Bigint operator - () {",
			"        Bigint res = (*this);",
			"        bool allzero = true; for (int i = 0; i < res.size(); ++i) if (res[i] != 0) { allzero = false; break; }",
			"        if (!allzero) res.sign *= -1;",
			"        return res;",
			"    }",
			"    inline const Bigint& operator += (const Bigint &x);",
			"    inline const Bigint& operator -= (const Bigint &x);",
			"    inline const Bigint& operator *= (long long x);",
			"    inline const Bigint& operator *= (const Bigint &x);",
			"    inline const Bigint& operator /= (long long x);",
			"    inline const Bigint& operator /= (const Bigint &x);",
			"    inline const Bigint& operator %= (long long x);",
			"    inline const Bigint& operator %= (const Bigint &x);",
			"};",
			" ",
			"inline Bigint abs(const Bigint &x) {",
			"    Bigint z = x;",
			"    if (z.sign == -1) z.sign = 1;",
			"    return z;",
			"}",
			"inline Bigint conv(const string &s) {",
			"    Bigint res = 0;",
			"    for (int i = 0; i < s.size(); ++i) {",
			"        res += (long long)(s[i] - '0');",
			"        if (i != s.size()-1) res *= 10;",
			"    }",
			"    return res;",
			"}",
			"ostream &operator << (ostream &os, const Bigint &x) {",
			"    if (x.sign == -1) os << '-';",
			"    int d = (int)x.size()-1;",
			"    for (d = (int)x.size()-1; d >= 0; --d) if (x[d] > 0) break;",
			"    if (d == -1) os << 0;",
			"    else os << x[d];",
			"    for (int i = d-1; i >= 0; --i) { os.width(Bigint::BASE_DIGIT); os.fill('0'); os << x[i]; }",
			"    return os;",
			"}",
			"istream &operator >> (istream &is, Bigint &x) {",
			"    string s; is >> s;",
			"    x = conv(s);",
			"    return is;",
			"}",
			"inline string tostr(const Bigint &x) {",
			"    stringstream ss;",
			"    ss << x;",
			"    return ss.str();",
			"}",
			"bool operator > (Bigint x, Bigint y) {",
			"    x.normalize(); y.normalize();",
			"    if (x.sign > y.sign) return true;",
			"    else if (x.sign < y.sign) return false;",
			"    else {",
			"        while (x.size() < y.size()) x.push_back(0);",
			"        while (x.size() > y.size()) y.push_back(0);",
			"        if (x.sign == 1) {",
			"            for (int i = (int)x.size()-1; i >= 0; --i) if (x[i] != y[i]) return x[i] > y[i];",
			"            return false;",
			"        }",
			"        else {",
			"            for (int i = (int)x.size()-1; i >= 0; --i) if (x[i] != y[i]) return x[i] < y[i];",
			"            return false;",
			"        }",
			"    }",
			"}",
			"bool operator < (Bigint x, Bigint y) { return y > x; }",
			"bool operator <= (Bigint x, Bigint y) { return !(x > y); }",
			"bool operator >= (Bigint x, Bigint y) { return !(y > x); }",
			"bool operator != (Bigint x, Bigint y) { return (x > y) || (y > x); }",
			"bool operator == (Bigint x, Bigint y) { return !(x > y) && !(y > x); }",
			" ",
			"inline Bigint operator + (Bigint x, Bigint y) {",
			"    while (x.size() < y.size()) x.push_back(0);",
			"    while (x.size() > y.size()) y.push_back(0);",
			"    Bigint z((int)x.size(), 0);",
			"    if (x.sign == y.sign) {",
			"        z.sign = x.sign;",
			"        for (int i = 0; i < x.size(); ++i) z[i] = x[i] + y[i];",
			"    }",
			"    else {",
			"        if (x.sign == -1) swap(x, y);",
			"        if (x >= -y) { z.sign = 1; for (int i = 0; i < x.size(); ++i) z[i] = x[i] - y[i]; }",
			"        else { z.sign = -1; for (int i = 0; i < x.size(); ++i) z[i] = y[i] - x[i]; }",
			"    }",
			"    return z.normalize();",
			"}",
			"inline Bigint operator - (Bigint x, Bigint y) {",
			"    y = -y;",
			"    return x + y;",
			"}",
			"inline Bigint operator * (Bigint x, long long a) {",
			"    Bigint z((int)x.size(), 0);",
			"    if ( (x.sign == 1 && a >= 0) || (x.sign == -1 && a < 0) ) z.sign = 1;",
			"    else z.sign = -1;",
			"    if (a < 0) a = -a;",
			"    for (int i = 0; i < x.size(); ++i) z[i] = x[i] * a;",
			"    return z.normalize();",
			"}",
			"inline Bigint operator * (Bigint x, Bigint y) {",
			"    int tx = (int)x.size()-1, ty = (int)y.size()-1;",
			"    for (tx = (int)x.size()-1; tx >= 0; --tx) if (x[tx] > 0) break;",
			"    for (ty = (int)y.size()-1; ty >= 0; --ty) if (y[ty] > 0) break;",
			"    Bigint z(tx+ty+5, 0);",
			"    if (x.sign == y.sign) z.sign = 1;",
			"    else z.sign = -1;",
			"    for (int i = 0; i <= tx; ++i) {",
			"        for (int j = 0; j <= ty && i+j < z.size()-1; ++j) {",
			"            long long val = x[i] * y[j] + z[i+j];",
			"            z[i+j+1] += val / Bigint::BASE;",
			"            z[i+j] = val % Bigint::BASE;",
			"        }",
			"    }",
			"    return z.normalize();",
			"}",
			"pair<Bigint, long long> divmod(Bigint x, long long a) {",
			"    long long c = 0, t = 0;",
			"    for (int i = (int)x.size()-1; i >= 0; --i) {",
			"        t = Bigint::BASE * c + x[i];",
			"        x[i] = t / a;",
			"        c = t % a;",
			"    }",
			"    x.normalize();",
			"    return pair<Bigint, long long>(x, c);",
			"}",
			"Bigint operator / (Bigint x, long long a) {",
			"    return divmod(x, a).first;",
			"}",
			"long long operator % (Bigint x, long long a) {",
			"    return divmod(x, a).second;",
			"}",
			"pair<Bigint, Bigint> divmod(Bigint x, Bigint y) {",
			"    Bigint zero = 0;",
			"    if (abs(x) < abs(y)) return pair<Bigint, Bigint>(zero, x);",
			"    Bigint ay = abs(y), q((int)x.size(), 0), r((int)y.size(), 0);",
			"    int tx = (int)x.size()-1;",
			"    for (tx = (int)x.size()-1; tx >= 0; --tx) if (x[tx] > 0) break;",
			"    for (int i = tx; i >= 0; --i) {",
			"        r = r * Bigint::BASE + x[i];",
			"        long long lo = 0, hi = Bigint::BASE;",
			"        if (r >= ay) {",
			"            while (hi - lo > 1) {",
			"                long long mid = (hi + lo) / 2;",
			"                if (ay * mid > r) hi = mid;",
			"                else lo = mid;",
			"            }",
			"            r = r - ay * lo;",
			"        }",
			"        q[i] = lo;",
			"    }",
			"    if (x.sign == -1 || y.sign == -1) q.sign = -1, r.sign = -1;",
			"    return make_pair(q.normalize(), r.normalize());",
			"}",
			"Bigint operator / (Bigint x, Bigint y) {",
			"    return divmod(x, y).first;",
			"}",
			"Bigint operator % (Bigint x, Bigint y) {",
			"    return divmod(x, y).second;",
			"}",
			"inline Bigint pow(Bigint a, long long n) {",
			"    Bigint res = 1;",
			"    while (n > 0) { if (n & 1) { res = res * a; } a = a * a; n >>= 1; }",
			"    return res;",
			"}",
			"Bigint sqrt(Bigint num) {",
			"    Bigint lo = 1, hi = num;",
			"    while (hi - lo > 1) {",
			"        Bigint med = (lo + hi) / 2;",
			"        if (med * med > num) hi = med;",
			"        else lo = med;",
			"    }",
			"    return lo;",
			"}",
			"inline const Bigint& Bigint::operator += (const Bigint &x) {*this = *this + x; return *this;}",
			"inline const Bigint& Bigint::operator -= (const Bigint &x) {*this = *this - x; return *this;}",
			"inline const Bigint& Bigint::operator *= (long long x) {*this = *this * x; return *this;}",
			"inline const Bigint& Bigint::operator *= (const Bigint &x) {*this = *this * x; return *this;}",
			"inline const Bigint& Bigint::operator /= (long long x) {*this = *this / x; return *this;}",
			"inline const Bigint& Bigint::operator /= (const Bigint &x) {*this = *this / x; return *this;}",
			"inline const Bigint& Bigint::operator %= (long long x) {*this = *this % x; return *this;}",
			"inline const Bigint& Bigint::operator %= (const Bigint &x) {*this = *this % x; return *this;}"
		],
		"description": "BigInt"
	},
	"geometry": {
		"prefix": "geo",
		"body": "#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n\n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nstruct EndPoint{\n  Point p;\n  int seg,st;\n  EndPoint(){}\n  EndPoint(Point p,int seg,int st):p(p),seg(seg),st(st){}\n  bool operator<(const EndPoint &ep)const{\n    if(p.y==ep.p.y) return st<ep.st;\n    return p.y<ep.p.y;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) is>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\nvector< vector<int> >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  return getDistanceSP(s,c.c)<=c.r;\n}\n\nint intersectCS(Circle c,Segment s){\n  if(norm(project(s,c.c)-c.c)-c.r*c.r>EPS) return 0;\n  double d1=abs(c.c-s.p1),d2=abs(c.c-s.p2);\n  if(d1<c.r+EPS&&d2<c.r+EPS) return 0;\n  if((d1<c.r-EPS&&d2>c.r+EPS)||(d1>c.r+EPS&&d2<c.r-EPS)) return 1;\n  Point h=project(s,c.c);\n  if(dot(s.p1-h,s.p2-h)<0) return 2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  for(int k=0;k<2;k++){\n    if(getDistanceSP(s1,s2.p1)<EPS) return s2.p1;\n    if(getDistanceSP(s1,s2.p2)<EPS) return s2.p2;\n    swap(s1,s2);\n  }\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCS(Circle c,Segment s){\n  Line l(s);\n  Polygon res=getCrossPointCL(c,l);\n  if(intersectCS(c,s)==2) return res;\n  if(res.size()>1u){\n    if(dot(l.p1-res[0],l.p2-res[0])>0) swap(res[0],res[1]);\n    res.pop_back();\n  }\n  return res;\n}\n\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n}\n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return res;\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n\n  return ls;\n}\n\ndouble closest_pair(Polygon &a,int l=0,int r=-1){\n  if(r<0){\n    r=a.size();\n    sort(a.begin(),a.end(),sort_x);\n  }\n  if(r-l<=1) return abs(a[0]-a[1]);\n  int m=(l+r)>>1;\n  double x=a[m].x;\n  double d=min(closest_pair(a,l,m),closest_pair(a,m,r));\n  inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);\n\n  Polygon b;\n  for(int i=l;i<r;i++){\n    if(fabs(a[i].x-x)>=d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dy=a[i].y-next(b.rbegin(),j)->y;\n      if(dy>=d) break;\n      d=min(d,abs(a[i]-*next(b.rbegin(),j)));\n    }\n    b.emplace_back(a[i]);\n  }\n  return d;\n}\n\nvector<vector<int> >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps){\n  int n=ss.size();\n  for(int i=0;i<n;i++){\n    ps.emplace_back(ss[i].p1);\n    ps.emplace_back(ss[i].p2);\n    for(int j=i+1;j<n;j++)\n      if(intersectSS(ss[i],ss[j]))\n        ps.emplace_back(getCrossPointSS(ss[i],ss[j]));\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n  vector<vector<int> > G(ps.size());\n  for(int i=0;i<n;i++){\n    vector<pair<double,int> > ls;\n    for(int j=0;j<(int)ps.size();j++)\n      if(getDistanceSP(ss[i],ps[j])<EPS)\n        ls.emplace_back(make_pair(norm(ss[i].p1-ps[j]),j));\n\n    sort(ls.begin(),ls.end());\n    for(int j=0;j+1<(int)ls.size();j++){\n      int a=ls[j].second,b=ls[j+1].second;\n      G[a].emplace_back(b);\n      G[b].emplace_back(a);\n    }\n  }\n  for(auto &v:G){\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n  }\n  return G;\n}\n\nint manhattanIntersection(vector<Segment> ss,const int inf){\n  const int BTM = 0;\n  const int LFT = 1;\n  const int RGH = 2;\n  const int TOP = 3;\n\n  int n=ss.size();\n  vector<EndPoint> ep;\n  for(int i=0;i<n;i++){\n    if(ss[i].p1.y==ss[i].p2.y){\n      if(ss[i].p1.x>ss[i].p2.x) swap(ss[i].p1,ss[i].p2);\n      ep.emplace_back(ss[i].p1,i,LFT);\n      ep.emplace_back(ss[i].p2,i,RGH);\n    }else{\n      if(ss[i].p1.y>ss[i].p2.y) swap(ss[i].p1,ss[i].p2);\n      ep.emplace_back(ss[i].p1,i,BTM);\n      ep.emplace_back(ss[i].p2,i,TOP);\n    }\n  }\n  sort(ep.begin(),ep.end());\n\n  set<int> bt;\n  bt.insert(inf);\n\n  int cnt=0;\n  for(int i=0;i<n*2;i++){\n    if(ep[i].st==TOP){\n      bt.erase(ep[i].p.x);\n    }else if(ep[i].st==BTM){\n      bt.emplace(ep[i].p.x);\n    }else if(ep[i].st==LFT){\n      auto b=bt.lower_bound(ss[ep[i].seg].p1.x);\n      auto e=bt.upper_bound(ss[ep[i].seg].p2.x);\n      cnt+=distance(b,e);\n    }\n  }\n\n  return cnt;\n}\n\ndouble area(Polygon ps,Circle c){\n  if(ps.size()<3u) return 0;\n  function<double(Circle, Point, Point)> dfs=\n    [&](Circle c,Point a,Point b){\n      Vector va=c.c-a,vb=c.c-b;\n      double f=cross(va,vb),res=0;\n      if(equals(f,0.0)) return res;\n      if(max(abs(va),abs(vb))<c.r+EPS) return f;\n      Vector d(dot(va,vb),cross(va,vb));\n      if(getDistanceSP(Segment(a,b),c.c)>c.r-EPS)\n        return c.r*c.r*atan2(d.y,d.x);\n      auto u=getCrossPointCS(c,Segment(a,b));\n      if(u.empty()) return res;\n      if(u.size()>1u&&dot(u[1]-u[0],a-u[0])>0) swap(u[0],u[1]);\n      u.emplace(u.begin(),a);\n      u.emplace_back(b);\n      for(int i=1;i<(int)u.size();i++)\n        res+=dfs(c,u[i-1],u[i]);\n      return res;\n    };\n  double res=0;\n  for(int i=0;i<(int)ps.size();i++)\n    res+=dfs(c,ps[i],ps[(i+1)%ps.size()]);\n  return res/2;\n}",
		"description": "幾何"
	},
	"LCA": {
		"prefix": "lca",
		"body": "/* LCA(G, root): 木 G に対する根を root として Lowest Common Ancestor を求める構造体\n    query(u,v): u と v の LCA を求める。計算量 O(logn)\n    前処理: O(nlogn)時間, O(nlogn)空間\n*/\nstruct LCA\n{\n  vector<vector<int>> parent; // parent[k][u]:= u の 2^k 先の親\n  vector<int> dist;           // root からの距離\n  LCA(const vector<vector<int>> &G, int root = 0) { init(G, root); }\n  // 初期化\n  void init(const vector<vector<int>> &G, int root = 0)\n  {\n    int V = G.size();\n    int K = 1;\n    while ((1 << K) < V)\n      K++;\n    parent.assign(K, vector<int>(V, -1));\n    dist.assign(V, -1);\n    dfs(G, root, -1, 0);\n    for (int k = 0; k + 1 < K; k++)\n    {\n      for (int v = 0; v < V; v++)\n      {\n        if (parent[k][v] < 0)\n        {\n          parent[k + 1][v] = -1;\n        }\n        else\n        {\n          parent[k + 1][v] = parent[k][parent[k][v]];\n        }\n      }\n    }\n  }\n  // 根からの距離と1つ先の頂点を求める\n  void dfs(const vector<vector<int>> &G, int v, int p, int d)\n  {\n    parent[0][v] = p;\n    dist[v] = d;\n    for (auto e : G[v])\n    {\n      if (e != p)\n        dfs(G, e, v, d + 1);\n    }\n  }\n  int query(int u, int v)\n  {\n    if (dist[u] < dist[v])\n      swap(u, v); // u の方が深いとする\n    int K = parent.size();\n    // LCA までの距離を同じにする\n    for (int k = 0; k < K; k++)\n    {\n      if ((dist[u] - dist[v]) >> k & 1)\n      {\n        u = parent[k][u];\n      }\n    }\n    // 二分探索で LCA を求める\n    if (u == v)\n      return u;\n    for (int k = K - 1; k >= 0; k--)\n    {\n      if (parent[k][u] != parent[k][v])\n      {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};",
		"description": ""
	},
}